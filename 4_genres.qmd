---
title: "Study 3: Genres and wellbeing"
output: html_document
---

::: {.callout-note}
TODOs:

- include iOS and android data
- have the steam genre data also come from the IGDB API (currently the simulated personas only play across 5 genres)
- potential upgrade for this is to add the session together if the hours are next to each other and the game title is the same (can't be done now because of how the titles are generated.
:::

## Load libraries and data


```{r}
#| label: load-libraries
#| code-summary: "Show code (load libraries)"

if (!require("pacman")) install.packages("pacman")
library(pacman)

p_load(knitr, tidyverse, dplyr, lme4, marginaleffects, interactions, data.table)

set.seed(8675309)
```

```{r}
#| label: load-data
#| code-summary: "Show code (load data)"

panel <- fread("data-synthetic/synPanelClean.csv.gz") |> 
  mutate(
    start_date = case_when(
      wave == 1 ~ as.Date("2024-05-01"),
      wave == 2 ~ as.Date("2024-05-15"),
      wave == 3 ~ as.Date("2024-05-29"),
      wave == 4 ~ as.Date("2024-06-12"),
      wave == 5 ~ as.Date("2024-06-26"),
      wave == 6 ~ as.Date("2024-07-10")
    ),
    end_date = start_date + 13  # Each wave covers a 14-day period
  )

diary <- read_csv("data-synthetic/synDiaryClean.csv.gz")
intake <- read_csv("data-synthetic/synIntakeClean.csv.gz")
ninRaw <- read_csv("data-synthetic/synNintendo.csv.gz")
xboxRaw <- read_csv("data-synthetic/synXbox.csv.gz") 
steamRaw <- read_csv("data-synthetic/synSteam.csv.gz")
iOSRaw <- read_csv("data-synthetic/syniOS.csv.gz")
androidRaw <- read_csv("data-synthetic/synAndroid.csv.gz")

```


## Merge data

We also perform some simple preprocessing here:
- We create a `start_date` and `end_date` column in the panel data to represent the start and end of each wave.
- We separate the genre column in the Nintendo, Xbox, and Steam data into five separate columns.
  - Xbox and Nintendo have roughly 4000 unique genres, which is too many to work with. We recode these into a smaller number of genres by separating the primary genres from the sub genres.

In contrast to Xbox and Nintendo data, Steam data is not session-level; rather, it is a total amount of time spent playing each game during the previous hour. So to calculate how much time each player spent playing each genre each day and create a variable for how many sessions, we need to recode the data to match the format of the other two datasets.


```{r}
#| label: merge-data
#| code-summary: "Show code (merge data)"

nin <- ninRaw |> 
  mutate(sessionEnd = sessionStart + minutes(round(duration)), .after = sessionStart) |> 
  separate(genre, into = c("genre1", "genre2", "genre3", "genre4", "genre5"), sep = ",", fill = "right")

xbox <- xboxRaw |> 
  mutate(sessionEnd = sessionStart + minutes(round(duration)), .after = sessionStart) |> 
  separate(genre, into = c("genre1", "genre2", "genre3", "genre4", "genre5"), sep = ",", fill = "right")

steam <- steamRaw |>
  rename(
    duration = minutes,
    titleID = Name,
  ) |> 
  mutate(sessionStart = date + hours(hour)) |> 
  separate(genre, into = c("genre1", "genre2", "genre3", "genre4", "genre5"), sep = ",", fill = "right") |> 
  group_by(pid, date) |>                    # Group by player ID and date
  mutate(session = row_number()) |>         # Create a sequential session number
  ungroup()       

telemetry <- bind_rows(nin, xbox, steam) |> 
  mutate(
    genre_grouped = case_when(
      genre1 %in% c("Action", "Adventure") ~ "Action/Adventure",
      genre1 %in% c("Hack and slash/Beat 'em up", "Fighting") ~ "Fighting",
      genre1 %in% c("Shooter") ~ "Shooter",
      genre1 %in% c("Real Time Strategy (RTS)", "Strategy", "Turn-based strategy (TBS)", "Tactical") ~ "Strategy",
      genre1 %in% c("Role-playing (RPG)") ~ "RPG",
      genre1 %in% c("MOBA") ~ "MOBA",
      genre1 %in% c("Puzzle", "Casual", "Card & Board Game") ~ "Casual/Puzzle",
      genre1 %in% c("Sport","Simulator", "Racing") ~ "Simulation/Sports/Racing",
      genre1 %in% c("Platform", "Arcade") ~ "Platform/Arcade",
      genre1 %in% c("Indie", "Music", "Visual Novel") ~ "Indie/Other",
      TRUE ~ "Other"  # This catches any genres not listed above
    ),
    genre_grouped = gsub("/", "_", tolower(genre_grouped))
  ) |> 
  group_by(pid, genre_grouped) |>
  mutate(previous_day_duration = lag(duration, 1)) |>
  ungroup()

```

Steam has 5 genres, Xbox has 19 genres, and Nintendo has 19 genres.

```{r}
#| label: genre-count

print(
  steam |>
  count(genre1) |>
  arrange(desc(n)))

print(
  xbox |>
  count(genre1) |>
  arrange(desc(n)))  

print(
  nin |>
  count(genre1) |>
  arrange(desc(n)))  

```


## Aggregate telemetry data

Aggregate playtime by genre within each wave for each participant, in wide format.

```{r}
#| label: aggregate playtime
#| code-summary: "Show code (aggregate playtime)"

aggregated_playtime <- telemetry |>
  mutate(wave = case_when(
    date >= as.Date("2024-05-01") & date <= as.Date("2024-05-14") ~ 1,
    date >= as.Date("2024-05-15") & date <= as.Date("2024-05-28") ~ 2,
    date >= as.Date("2024-05-29") & date <= as.Date("2024-06-11") ~ 3,
    date >= as.Date("2024-06-12") & date <= as.Date("2024-06-25") ~ 4,
    date >= as.Date("2024-06-26") & date <= as.Date("2024-07-09") ~ 5,
    date >= as.Date("2024-07-10") & date <= as.Date("2024-07-23") ~ 6
  )) |>
  group_by(pid, wave, genre_grouped) |>
  summarise(time = sum(duration, na.rm = TRUE), .groups = "drop") |>
  pivot_wider(
    names_from = genre_grouped, 
    values_from = time, 
    values_fill = 0, # Fill missing values with 0
    names_prefix = "time_"
  ) %>%
  mutate(
    total_time_all_genres = rowSums(select(., starts_with("time_")), na.rm = TRUE), # Calculate total time
    across(starts_with("time_"), ~ . / total_time_all_genres, .names = "prop_{.col}"), # Calculate proportion of time for each genre
  )

# get the variable names
genre_vars <- aggregated_playtime |> 
  select(starts_with("time_")) |> 
  colnames()

# demean
aggregated_playtime <- aggregated_playtime |> 
  bind_cols(
    datawizard::demean(aggregated_playtime, select = c(genre_vars, "total_time_all_genres"), by = "pid")
  ) |> 
  left_join(panel, by = c("pid", "wave"))

head(aggregated_playtime)
```


## Analysis

Data is analyzed using a multilevel model to account for the nested structure of the data, where repeated measurements (6 bi-weekly waves) are nested within participants. In this analysis, we examine the relationship between playtime spent on different game genres and well-being. We hypothesize that the relationship between playtime and well-being varies by genre.

within-person analysis, on with 6 bi-weekly measurement waves where wellbeing is measured for the last 2 weeks. So playtime needs to be aggregated over the 2 week time period and the proportion of total playtime spend on each genre needs to be calculated. 

## H1. The overall effect of playtime on wellbeing

Fit a REWB model of playtime and WB.

```{r}
#| label: h1_model
#| code-summary: "Show code (h1_model)"

h1_total_time <- lmer(
  wemwbs ~ total_time_all_genres_within + total_time_all_genres_between + (1 + total_time_all_genres_within | pid), 
  data = aggregated_playtime
)

summary(h1_total_time)
```

### Equivalence test

```{r}
#| label: h1_equivalence
#| code-summary: "Show code (h1_equivalence)"

hypotheses(h1_total_time, "total_time_all_genres_within = 0", equivalence = c(-.06, .06))

```


## H2. genre moderates the relationship between playtime and wellbeing

### Raw model

```{r}
#| label: h2_raw_model
#| code-summary: "Show code (h3_model)"

## raw
fit_h2_raw <- lmer(
  paste("wemwbs ~", 
    paste(genre_vars, collapse = "+"), 
  "+ (1 | pid)"),
  aggregated_playtime
)
summary(fit_h2_raw)
```

### REWB model

Interpretations:

- `time_*_between`: "Group-level effect": People who play x + 1 units more of genre_* report higher/lower `wemwbs` scores
- `time_*_within`: "Within-person effect": During a period when people play x + 1 units more of genre_* they report higher/lower `wemwbs` scores

```{r}
#| label: h2_rewb_model
#| code-summary: "Show code (h2_rewb_model)"

# get the variable names
genre_vars_demean <- aggregated_playtime |>
  select(ends_with(c("_within", "_between"))) |>
  colnames() |>
  sort()

## rewb
fit_h2_rewb <- lmer(
  paste(
      "wemwbs ~", paste(genre_vars_demean, collapse = "+"),
      "+ (1 | pid)"
    ),
  aggregated_playtime
)
summary(fit_h2_rewb)

```

  - Not possible to model all `genre_*_within` as random. Unidentifiable model.
  - **Inference**: can do six-billion pair-wise comparisons - fishing expedition.


Ideally, the demeaned variables should be included as random slopes. However, this will likely lead to identifiability issues. Here we fit the model with random slopes, but without a correlation between slopes and intercepts.

```{r}
#| label: h2_rewb_re_slopes
#| code-summary: "Show code (h3_rewb_re_slopes)"

# get the variable names
genre_within_wars <- aggregated_playtime |>
  select(ends_with(c("_within"))) |>
  select(-total_time_all_genres_within) |> 
  colnames() |>
  sort()

# fit model
fit_h2_rewb_re_slopes <- lmer(
  paste(
      "wemwbs ~", paste(genre_vars_demean, collapse = "+"),
      "+ (1 +",
      paste(genre_within_wars, collapse = "+"),
      "|| pid)"
    ),
  aggregated_playtime
)
summary(fit_h2_rewb_re_slopes)
```

### Plot all estimates

```{r}
#| label: plot-estimates
#| code-summary: "Show code (plot estimates)"

ests_fit_h2_rewb <- avg_comparisons(fit_h2_rewb) |> 
  as.data.frame()

ests_fit_h2_rewb |> 
ggplot(aes(estimate, term)) +
  geom_point() +
  geom_linerange(
    aes(ymin = conf.low, ymax = conf.high)
  )
```

Jointly test the null that all genre effects are zero vs the alternative that at least one is non-zero. Testing between and within variables separately?
```{r}
#| label: joint-hypotheses
#| code-summary: "Show code (joint hypotheses)"

hypotheses(fit_h2_rewb, joint = "_between")
hypotheses(fit_h2_rewb, joint = "_within")
```

Pair-wise comparison of all *_between coefficients. (The table is only showing the first 10). We will run the same code for within-person genre effects.

```{r}
#| label: pairwise-tests
#| code-summary: "Show code (pairwise tests)"

ests_pairwise <- hypotheses(fit_h2_rewb, "pairwise")
between_vars <- aggregated_playtime |>
  select(ends_with(c("_between"))) |>
  colnames()

# pick all *_between pairwise comparisons
tests <- expand.grid(a = between_vars, b = between_vars) |> 
  filter(a != b) |> 
  mutate(c = paste(a, "-", b))

# show 10 of the pairwise tests
ests_pairwise |> 
  filter(term %in% tests$c) |> 
  head(10) |> 
  kable()
```

We can also test if the coefficients are greater than a specific value, for example by comparing it to the point estimate from model X (effect of total playtime on WB). Although, this ignores the uncertainty in the reference value.

```{r}
#| label: hypotheses
#| code-summary: "Show code (hypotheses)"

# 0.4 is just a placeholder
hypotheses(fit_h2_rewb, "b* = 0.4")
```

