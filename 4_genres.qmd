---
title: "Study 3: Genres and wellbeing"
output: html_document
editor_options: 
  chunk_output_type: console
execute: 
  warning: false
page-layout: full
format:
  html:
    code-fold: true
    code-summary: "Show the code"
bibliography: references.bib
---

# Preamble

```{r}
#| label: opts

knitr::opts_chunk$set(
  echo = knitr::is_html_output(),
  warning = FALSE,
  message = FALSE,
  output = TRUE
)

set.seed(8675309)

```

```{r}
#| label: load-libraries

if (!require("pacman")) install.packages("pacman"); library(pacman)

p_load(tidyverse, dplyr, lme4, marginaleffects, interactions)

# not sure if marginaleffects is needed and what it does
```

# Load data

```{r}
#| label: load-data

pan <- read_csv("data-synthetic/synPanel.csv")

# the below has been run in the preprocessing script

# diary <- read_csv("data-synthetic/synDiaryClean.csv").      # has been run in basic needs script
 intake <- read_csv("data-synthetic/synIntake.csv")
 nin <- read_csv("data-synthetic/synNintendo.csv") |> 
   mutate(sessionEnd = sessionStart + minutes(round(duration)), .after = sessionStart)
 xbox <- read_csv("data-synthetic/synXbox.csv") |> 
   mutate(sessionEnd = sessionStart + minutes(round(duration)), .after = sessionStart)
 steam <- read_csv("data-synthetic/synSteam.csv") |> 
   mutate(sessionStart = date + hours(hour))

```

# recode genre data

xbox and nintendo have rpugly 4000 unique genres, which is too many to work with. We will recode these into a smaller number of genres by seperating the primary genres from the sub genres.

# seperate the genres into primary and secondary genres

```{r}
steam <- steam |>
  separate(genre, into = c("genre1", "genre2", "genre3", "genre4", "genre5"), sep = ",", fill = "right")


xbox <- xbox |>
  separate(genre, into = c("genre1", "genre2", "genre3", "genre4", "genre5"), sep = ",", fill = "right")

nin <- nin |>
  separate(genre, into = c("genre1", "genre2", "genre3", "genre4", "genre5"), sep = ",", fill = "right")

```

# check how many genres there are

steam has 5 genres, xbox has 19 genres, and nintendo has 19 genres.

```{r}
#| label: genre-count

print(
  steam |>
  count(genre1) |>
  arrange(desc(n)))

print(
  xbox |>
  count(genre1) |>
  arrange(desc(n)))  

print(
  nin |>
  count(genre1) |>
  arrange(desc(n)))  

```

## to do

-   have the steam genre data also come from the IGDB API
-   group some genres together like:
    -   "Real Time Strategy (RTS)" and "Turn Based Strategy (TBS)" into "Strategy"
    -   "puzzle" and " card & board game"
    -   "fighting" and "beat 'em up"

# recode steam data

In contrast to Xbox and Nintendo data, Steam data is not session-level; rather, it is a total amount of time spent playing each game during the previous hour. So to calculate how much time each player spent playing each genre each day and create a variable for how many sessions, we need to recode the data to match the format of the other two datasets.

```{r}
#| label: create daily session count

# Create the session column
steam <- steam |>
  group_by(pid, date) |>                    # Group by player ID and date
  mutate(session = row_number()) |>         # Create a sequential session number
  ungroup()                                  

print(head(steam))

```

## to do
- potential upgrade for this is to add the session together if the hours are next to each other and the game title is the same (can't be done now because of how the titles are generated.

# append data

```{r}
#| label: Get all unique column names across the three datasets

all_columns <- union(union(names(nin), names(xbox)), names(steam))
print(all_columns)

```

```{r}
# Rename variables in the steam data frame
steam <- steam |>
  rename(
    duration = minutes,
    titleID = Name,
  )
```


```{r}
#| label: order the variables


steam <- steam |>
  select( pid, day, date, platform, session, titleID, sessionStart, duration, genre1, genre2, genre3, genre4, genre5) # did not have sessionEnd

nin <- nin |>
  select( pid, day, date, platform, session, titleID, sessionStart, duration, genre1, genre2, genre3, genre4, genre5) # removed sessionEnd

xbox <- xbox |>
  select( pid, day, date, platform, session, titleID, sessionStart, duration, genre1, genre2, genre3, genre4, genre5) # removed sessionEnd
```


```{r}
#| label: append data
telemetry <- bind_rows(nin, xbox, steam)
```

# Save data

```{r}
#| label: save-data

write_csv(telemetry, "data-synthetic/telemetry.csv")

```


```{r}
# recode steam data to match to xbox and nin

# Calculate total duration and number of sessions per player per day per genre
steam_aggregated <- steam %>%
  group_by(pid, date, genre1) %>%           # Group by player ID, date, and genre
  summarise(
    total_duration = sum(minutes, na.rm = TRUE),  # Sum total minutes played
    num_sessions = n()                            # Count the number of sessions (rows)
  ) %>%
  ungroup()                                      

# View the result
print(steam_aggregated)
```

# Clean Panel

Here we want to: - recode the panel data to numeric values - calculate mean scores of relevant variables - calculate within- and between-person centered variables - recode the displaced activity data into categories (randomly assigned, for now) - calculate some variables based on the telemetry

```{r}
# write code to glimpse synPanel
glimpse(synPanel)


#calculate variables

#wellbeing
#life satisfaction
#depressive symptoms

```

# Analysis

```{r}
#| label: load-data

diary <- read_csv("data-synthetic/synDiaryClean.csv") # requires that the preprocessing script has been run
intake <- read_csv("data-synthetic/synIntake.csv")
nin <- read_csv("data-synthetic/synNintendo.csv")
xbox <- read_csv("data-synthetic/synXbox.csv")
steam <- read_csv("data-synthetic/synXbox.csv")

```

```{r}
#| label: merge data

your_data <- panel |> 
  left_join(intake |> select(pid, age, gender, eduLevel, employment), 
            by = "pid") |> 
  mutate(pid = as.character(pid)) |>
  
  # this is needed otherwise nlme and marginaleffects don't play nicely
  mutate(
    gender = factor(gender),
    eduLevel = factor(eduLevel),
    employment = factor(employment),
    day = factor(day)
  )

```

## H1. There is no relationship between playtime and wellbeing

This Basic Random Intercept Model allows the relationship between playtime and well-being to vary across players (random intercept) but assumes the effect of playtime is the same for all genres.

```{r}
#| label: h1-model
h1model1 <- lmer(wellbeing ~ playtime + genre + (1 | pid), data = your_data)

summary(h1model1)
```

This Random Slope Model allows the relationship between playtime and well-being to vary across players (random intercept) and genres (random slope).

```{r}
#| label: h1-model2
h1model2 <- lmer(wellbeing ~ playtime + genre + (playtime | pid), data = your_data)

summary(h1model2)
```

## H2. genre moderates the relationship between playtime and wellbeing

This Cross-Level Interaction Model explores whether the effect of playtime on well-being differs by genre.

```{r}
h2model1 <- lmer(wellbeing ~ playtime * genre + (playtime | pid), data = your_data)

summary(h2model1)
```

## Model diagnostics

```{r}
# Plot residuals
plot(model3)

# Check random effects
ranef(model3)

# Assess model fit
AIC(model1, model2, model3)
```

## Interpretation

```         
•   Fixed Effects: The interaction term (e.g., playtime:genre) will indicate how much the effect of playtime on well-being varies by genre.
•   Random Effects: The variance components for player_id will indicate how much the baseline well-being and the relationship between playtime and well-being vary across players.
```

##visualization

```{r}

# Plot interaction
interact_plot(model3, pred = playtime, modx = genre, plot.points = TRUE)

```

## reporting

In your report, you should detail:

```         
•   The overall fixed effect estimates for playtime and genre.
•   How much the relationship between playtime and well-being varies across players (random effects).
•   The significance and effect size of the interaction between playtime and genre, if present.
```
