---
title: "Study 3: Genres and wellbeing"
output: html_document
editor_options: 
  chunk_output_type: console
execute: 
  warning: false
page-layout: full
format:
  html:
    code-fold: true
    code-summary: "Show the code"
bibliography: references.bib
---

# Preamble

```{r}
#| label: opts

knitr::opts_chunk$set(
  echo = knitr::is_html_output(),
  warning = FALSE,
  message = FALSE,
  output = TRUE
)

set.seed(8675309)

```

```{r}
#| label: load-libraries

if (!require("pacman")) install.packages("pacman"); library(pacman)

p_load(knitr, tidyverse, dplyr, lme4, marginaleffects, interactions)

# not sure if marginaleffects is needed and what it does
```

## Load data

```{r}
#| label: load-data

pan <- read_csv("data-synthetic/synPanelClean.csv.gz")

# the below has been run in the preprocessing script

# diary <- read_csv("data-synthetic/synDiaryClean.csv").      # has been run in basic needs script
 intake <- read_csv("data-synthetic/synIntake.csv.gz")
 nin <- read_csv("data-synthetic/synNintendo.csv.gz") |> 
   mutate(sessionEnd = sessionStart + minutes(round(duration)), .after = sessionStart)
 xbox <- read_csv("data-synthetic/synXbox.csv.gz") |> 
   mutate(sessionEnd = sessionStart + minutes(round(duration)), .after = sessionStart)
 steam <- read_csv("data-synthetic/synSteam.csv.gz") |> 
   mutate(sessionStart = date + hours(hour))

```

## recode genre data

xbox and nintendo have rpugly 4000 unique genres, which is too many to work with. We will recode these into a smaller number of genres by seperating the primary genres from the sub genres.

## seperate the genres into primary and secondary genres

```{r}
steam <- steam |>
  separate(genre, into = c("genre1", "genre2", "genre3", "genre4", "genre5"), sep = ",", fill = "right")


xbox <- xbox |>
  separate(genre, into = c("genre1", "genre2", "genre3", "genre4", "genre5"), sep = ",", fill = "right")

nin <- nin |>
  separate(genre, into = c("genre1", "genre2", "genre3", "genre4", "genre5"), sep = ",", fill = "right")

```

## check how many genres there are

steam has 5 genres, xbox has 19 genres, and nintendo has 19 genres.

```{r}
#| label: genre-count

print(
  steam |>
  count(genre1) |>
  arrange(desc(n)))

print(
  xbox |>
  count(genre1) |>
  arrange(desc(n)))  

print(
  nin |>
  count(genre1) |>
  arrange(desc(n)))  

```

## to do

-   have the steam genre data also come from the IGDB API
-   group some genres together like:
    -   "Real Time Strategy (RTS)" and "Turn Based Strategy (TBS)" into "Strategy"
    -   "puzzle" and " card & board game"
    -   "fighting" and "beat 'em up"

## recode steam data

In contrast to Xbox and Nintendo data, Steam data is not session-level; rather, it is a total amount of time spent playing each game during the previous hour. So to calculate how much time each player spent playing each genre each day and create a variable for how many sessions, we need to recode the data to match the format of the other two datasets.

```{r}
#| label: create daily session count

# Create the session column
steam <- steam |>
  group_by(pid, date) |>                    # Group by player ID and date
  mutate(session = row_number()) |>         # Create a sequential session number
  ungroup()                                  

print(head(steam))

```

## to do
- potential upgrade for this is to add the session together if the hours are next to each other and the game title is the same (can't be done now because of how the titles are generated.

## append data

```{r}
#| label: Get all unique column names across the three datasets

all_columns <- union(union(names(nin), names(xbox)), names(steam))
print(all_columns)

```

```{r}
# Rename variables in the steam data frame
steam <- steam |>
  rename(
    duration = minutes,
    titleID = Name,
  )
```


```{r}
#| label: order the variables


steam <- steam |>
  select( pid, day, date, platform, session, titleID, sessionStart, duration, genre1, genre2, genre3, genre4, genre5) # did not have sessionEnd

nin <- nin |>
  select( pid, day, date, platform, session, titleID, sessionStart, duration, genre1, genre2, genre3, genre4, genre5) # removed sessionEnd

xbox <- xbox |>
  select( pid, day, date, platform, session, titleID, sessionStart, duration, genre1, genre2, genre3, genre4, genre5) # removed sessionEnd
```


```{r}
#| label: append data
telemetry <- bind_rows(nin, xbox, steam)
```

## Save data

```{r}
#| label: save-data

write_csv(telemetry, "data-synthetic/telemetry.csv.gz")

```




# Analysis Panel Data

Panel data is analyzed using a multilevel model to account for the nested structure of the data, where repeated measurements (6 bi-weekly waves) are nested within participants. In this analysis, we examine the relationship between playtime spent on different game genres and well-being. We hypothesize that the relationship between playtime and well-being varies by genre.

within-person analysis, on with 6 bi-weekly measurement waves where wellbeing is measured for the last 2 weeks. So playtime needs to be aggregated over the 2 week time period and the proportion of total playtime spend on each genre needs to be calculated. 

## Load data
```{r}
#| label: load-data2

panel_data <- read_csv("data-synthetic/synPanelClean.csv.gz")
telemetry_data <- read_csv("data-synthetic/telemetry.csv.gz")

```

## Recode panel data
Recode panel data to include the start and end dates for each wave.

```{r}
#| label: define the waves

# check if date is in Date format
telemetry_data$date <- as.Date(telemetry_data$date)

# Define the start and end dates for each wave in the panel data
panel_data <- panel_data |>
  mutate(
    start_date = case_when(
      wave == 1 ~ as.Date("2024-05-01"),
      wave == 2 ~ as.Date("2024-05-15"),
      wave == 3 ~ as.Date("2024-05-29"),
      wave == 4 ~ as.Date("2024-06-12"),
      wave == 5 ~ as.Date("2024-06-26"),
      wave == 6 ~ as.Date("2024-07-10")
    ),
    end_date = start_date + 13  # Each wave covers a 14-day period
  )

```

## Recode genres
There are still too many unique genre values in the genre1 column. We will group genres into broader categories to reduce the number of categories for analysis.

```{r}
#| label: check unique genres 

# Count the number of unique values in the genre1 column
unique_genres <- telemetry_data |>
  summarise(n_unique_genres = n_distinct(genre1))

# View the result
print(unique_genres)

# Display the distinct genres in the genre1 column
distinct_genres <- telemetry_data |>
  distinct(genre1)

# View the distinct genres
print(distinct_genres, n = Inf)
```

Group genres into broader categories to reduce the number of categories for analysis
```{r}
#| label: group genres

telemetry_data <- telemetry_data |>
  mutate(
    genre_grouped = case_when(
      genre1 %in% c("Action", "Adventure") ~ "Action/Adventure",
      genre1 %in% c("Hack and slash/Beat 'em up", "Fighting") ~ "Fighting",
      genre1 %in% c("Shooter") ~ "Shooter",
      genre1 %in% c("Real Time Strategy (RTS)", "Strategy", "Turn-based strategy (TBS)", "Tactical") ~ "Strategy",
      genre1 %in% c("Role-playing (RPG)") ~ "RPG",
      genre1 %in% c("MOBA") ~ "MOBA",
      genre1 %in% c("Puzzle", "Casual", "Card & Board Game") ~ "Casual/Puzzle",
      genre1 %in% c("Sport","Simulator", "Racing") ~ "Simulation/Sports/Racing",
      genre1 %in% c("Platform", "Arcade") ~ "Platform/Arcade",
      genre1 %in% c("Indie", "Music", "Visual Novel") ~ "Indie/Other",
      TRUE ~ "Other"  # This catches any genres not listed above
    )
  )

# TO DO: maybe take away categories like "indie" etc and take the second or third category
```

## Recode telemetry data
Aggregate playtime by genre within each wave for each participant.

```{r}
#| label: aggregate playtime

aggregated_playtime <- telemetry_data |>
  mutate(wave = case_when(
    date >= as.Date("2024-05-01") & date <= as.Date("2024-05-14") ~ 1,
    date >= as.Date("2024-05-15") & date <= as.Date("2024-05-28") ~ 2,
    date >= as.Date("2024-05-29") & date <= as.Date("2024-06-11") ~ 3,
    date >= as.Date("2024-06-12") & date <= as.Date("2024-06-25") ~ 4,
    date >= as.Date("2024-06-26") & date <= as.Date("2024-07-09") ~ 5,
    date >= as.Date("2024-07-10") & date <= as.Date("2024-07-23") ~ 6
  )) |>
  group_by(pid, wave, genre_grouped) |>
  summarise(total_time = sum(duration, na.rm = TRUE)) |>
  ungroup()
```

Calculate the total playtime across all genres per wave for each participant

```{r}
#| label: calculate total playtime

total_playtime_per_wave <- aggregated_playtime |>
  group_by(pid, wave) |>
  summarise(total_time_all_genres = sum(total_time, na.rm = TRUE)) |>
  ungroup()
```

Calculate the proportion of time spent on each genre relative to the total playtime across all genres for each participant in each wave

```{r}
#| label: calculate proportion time

aggregated_playtime <- aggregated_playtime |>
  left_join(total_playtime_per_wave, by = c("pid", "wave")) |>
  mutate(proportion_time = total_time / total_time_all_genres)
```

## Merge data
Merge the aggregated playtime data with the well-being panel data

```{r}
#| label: merge data

panel_combined_data <- panel_data |>
  left_join(aggregated_playtime, by = c("pid", "wave"))
```


# H2. The overall effect of playtime on wellbeing
Fit a REWB model of playtime and WB.
```{r}
panel_data_playtime <- panel_data |>
  left_join(
    total_playtime_per_wave, by = c("pid", "wave")
    ) 
panel_data_playtime <- panel_data_playtime |> 
  bind_cols(
    datawizard::demean(panel_data_playtime, select = "total_time_all_genres", by = "pid") 
  )
h2_total_time <- lmer(
  wemwbs ~ total_time_all_genres_within + 
  total_time_all_genres_between + 
  (1 + total_time_all_genres_within | pid), 
  data = panel_data_playtime
  )

summary(h2_total_time)
```
# H3. genre moderates the relationship between playtime and wellbeing

Organize genre playtime in wide format.
```{r}
#| label: wide-format
panel_genre_wide <- panel_combined_data |> 
  filter(!is.na(genre_grouped)) |> 
  select(wave, wemwbs, total_time, total_time_all_genres, genre_grouped, pid)  |> 
  mutate(
    genre_grouped = gsub("/", "_", tolower(genre_grouped))
  ) |> 
  pivot_wider(
    names_from = genre_grouped,
    names_prefix = "genre_",
    values_from = total_time,
    values_fill = 0
  )
# get the variable names
genre_vars <- panel_genre_wide |> 
  select(starts_with("genre_")) |> 
  colnames()
# demean
panel_genre_wide <- panel_genre_wide |> 
  bind_cols(
    datawizard::demean(panel_genre_wide, select = genre_vars, by = "pid")
  ) 

head(panel_genre_wide)
```

Raw model
```{r}
## raw
fit_h3_raw <- lmer(
  paste("wemwbs ~", 
    paste(genre_vars, collapse = "+"), 
  "+ (1 | pid)"),
  panel_genre_wide
)
summary(fit_h3_raw)
```

REWB model. Interpretations:

- `genre_*_between`: "Group-level effect": People who play x + 1 units more of genre_* report higher/lower `wemwbs` scores
- `genre_*_within`: "Within-person effect": During a period when people play x + 1 units more of genre_* they report higher/lower `wemwbs` scores

```{r}
# get the variable names
genre_vars_demean <- panel_genre_wide |>
  select(ends_with(c("_within", "_between"))) |>
  colnames() |>
  sort()

## rewb
fit_h3_rewb <- lmer(
  paste(
      "wemwbs ~", paste(genre_vars_demean, collapse = "+"),
      "+ (1 | pid)"
    ),
  panel_genre_wide
)
summary(fit_h3_rewb)

```

  - Not possible to model all `genre_*_within` as random. Unidentifiable model.
  - **Inference**: can do six-billion pair-wise comparisons - fishing expedition.


Ideally, the demeaned variables should be included as random slopes. However, this will likely lead to identifiability issues. Here we fit the model with random slopes, but without a correlation between slopes and intercepts.
```{r}
# get the variable names
genre_within_wars <- panel_genre_wide |>
  select(ends_with(c("_within"))) |>
  colnames() |>
  sort()

# fit model
fit_h3_rewb_re_slopes <- lmer(
  paste(
      "wemwbs ~", paste(genre_vars_demean, collapse = "+"),
      "+ (1 +",
      paste(genre_within_wars, collapse = "+"),
      "|| pid)"
    ),
  panel_genre_wide
)
summary(fit_h3_rewb_re_slopes)
```

Plot all estimates

```{r}
ests_fit_h3_rewb <- avg_comparisons(fit_h3_rewb) |> 
  as.data.frame()

ests_fit_h3_rewb |> 
ggplot( 
  aes(estimate, term)
  ) +
   geom_point() +
   geom_linerange(
    aes(ymin = conf.low, ymax = conf.high)
    )
```

Jointly test the null that all genre effects are zero vs the alternative that at least one is non-zero. Testing between and within variables separately?
```{r}
hypotheses(fit_h3_rewb, joint = "_between")
hypotheses(fit_h3_rewb, joint = "_within")
```

Pair-wise comparison of all *_between coefficients. (The table is only showing the first 10). We will run the same code for within-person genre effects.

```{r}
ests_pairwise <- hypotheses(fit_h3_rewb, "pairwise")
between_vars <- panel_genre_wide |>
  select(ends_with(c("_between"))) |>
  colnames()

# pick all *_between pairwise comparisons
tests <- expand.grid(a = between_vars, b = between_vars) |> 
  filter(a != b) |> 
  mutate(c = paste(a, "-", b))

# show 10 of the pairwise tests
ests_pairwise |> 
  filter(term %in% tests$c) |> 
  head(10) |> 
  kable()
```

We can also test if the coefficients are greater than a specific value, for example by comparing it to the point estimate from model X (effect of total playtime on WB). Although, this ignores the uncertainty in the reference value.

```{r}
# 0.4 is just a placeholder
hypotheses(fit_h3_rewb, "b* = 0.4")
```


# Analysis Diary data (Daily trends in daily life satisfaction)

## Load data

```{r}
#| label: Load the diary data

diary_data <- read_csv("data-synthetic/synDiaryClean.csv.gz")
```

## Recode diary data
Create a lagged version of the daily playtime data so that we can predict life satisfaction based on the previous day's playtime.

```{r}
#| label: create lagged playtime

telemetry_data <- telemetry_data |>
  group_by(pid, genre_grouped) |>
  mutate(previous_day_duration = lag(duration, 1)) |>
  ungroup()
```

Calculate the total playtime for each genre for each day

```{r}
#| label: calculate daily playtime per genre

daily_playtime <- telemetry_data |>
  group_by(pid, day, genre_grouped) |>
  summarise(total_previous_day_duration = sum(previous_day_duration, na.rm = TRUE)) |>
  ungroup()
```

## Merge data

```{r}
#| label: merge data-2
diary_combined_data <- diary_data |>
  left_join(daily_playtime, by = c("pid", "day"))
```

# H1. Previous day playtime is positivly with daily life satisfaction

Predicting life satisfaction based on previous day's playtime 

```{r}
#| label: h1_model_diary

h1_model_diary <- lmer(lifeSat_1 ~ total_previous_day_duration + (1 | pid), data = diary_combined_data)

summary(h1_model_diary, correlation=TRUE)

# Plot the predictions for the effect of total_previous_day_duration
plot_predictions(h1_model_diary, condition = c("total_previous_day_duration"), vcov = TRUE)

```

# H2. Genre moderates the relationship between previous day playtime and daily life satisfaction

Predicting life satisfaction based on previous day's playtime and how it varies by genre
```{r}
#| label: h2_model_diary

h2_model_diary <- lmer(lifeSat_1 ~ total_previous_day_duration * genre_grouped + (1 | pid), data = diary_combined_data)

summary(h2_model_diary, correlation=TRUE)

# Plot the predictions for the interaction effect between total_previous_day_duration and genre1
plot_predictions(h2_model_diary, condition = c("total_previous_day_duration", "genre_grouped"), vcov = TRUE)

```

