---
title: "Study 3: Genres and wellbeing"
output: html_document
editor_options: 
  chunk_output_type: console
execute: 
  warning: false
page-layout: full
format:
  html:
    code-fold: true
    code-summary: "Show the code"
bibliography: references.bib
---

# Preamble

```{r}
#| label: opts

knitr::opts_chunk$set(
  echo = knitr::is_html_output(),
  warning = FALSE,
  message = FALSE,
  output = TRUE
)

set.seed(8675309)

```

```{r}
#| label: load-libraries

if (!require("pacman")) install.packages("pacman"); library(pacman)

p_load(tidyverse, dplyr, lme4, marginaleffects, interactions)

# not sure if marginaleffects is needed and what it does
```

## Load data

```{r}
#| label: load-data

pan <- read_csv("data-synthetic/synPanelClean.csv")

# the below has been run in the preprocessing script

# diary <- read_csv("data-synthetic/synDiaryClean.csv").      # has been run in basic needs script
 intake <- read_csv("data-synthetic/synIntake.csv")
 nin <- read_csv("data-synthetic/synNintendo.csv") |> 
   mutate(sessionEnd = sessionStart + minutes(round(duration)), .after = sessionStart)
 xbox <- read_csv("data-synthetic/synXbox.csv") |> 
   mutate(sessionEnd = sessionStart + minutes(round(duration)), .after = sessionStart)
 steam <- read_csv("data-synthetic/synSteam.csv") |> 
   mutate(sessionStart = date + hours(hour))

```

## recode genre data

xbox and nintendo have rpugly 4000 unique genres, which is too many to work with. We will recode these into a smaller number of genres by seperating the primary genres from the sub genres.

## seperate the genres into primary and secondary genres

```{r}
steam <- steam |>
  separate(genre, into = c("genre1", "genre2", "genre3", "genre4", "genre5"), sep = ",", fill = "right")


xbox <- xbox |>
  separate(genre, into = c("genre1", "genre2", "genre3", "genre4", "genre5"), sep = ",", fill = "right")

nin <- nin |>
  separate(genre, into = c("genre1", "genre2", "genre3", "genre4", "genre5"), sep = ",", fill = "right")

```

## check how many genres there are

steam has 5 genres, xbox has 19 genres, and nintendo has 19 genres.

```{r}
#| label: genre-count

print(
  steam |>
  count(genre1) |>
  arrange(desc(n)))

print(
  xbox |>
  count(genre1) |>
  arrange(desc(n)))  

print(
  nin |>
  count(genre1) |>
  arrange(desc(n)))  

```

## to do

-   have the steam genre data also come from the IGDB API
-   group some genres together like:
    -   "Real Time Strategy (RTS)" and "Turn Based Strategy (TBS)" into "Strategy"
    -   "puzzle" and " card & board game"
    -   "fighting" and "beat 'em up"

## recode steam data

In contrast to Xbox and Nintendo data, Steam data is not session-level; rather, it is a total amount of time spent playing each game during the previous hour. So to calculate how much time each player spent playing each genre each day and create a variable for how many sessions, we need to recode the data to match the format of the other two datasets.

```{r}
#| label: create daily session count

# Create the session column
steam <- steam |>
  group_by(pid, date) |>                    # Group by player ID and date
  mutate(session = row_number()) |>         # Create a sequential session number
  ungroup()                                  

print(head(steam))

```

## to do
- potential upgrade for this is to add the session together if the hours are next to each other and the game title is the same (can't be done now because of how the titles are generated.

## append data

```{r}
#| label: Get all unique column names across the three datasets

all_columns <- union(union(names(nin), names(xbox)), names(steam))
print(all_columns)

```

```{r}
# Rename variables in the steam data frame
steam <- steam |>
  rename(
    duration = minutes,
    titleID = Name,
  )
```


```{r}
#| label: order the variables


steam <- steam |>
  select( pid, day, date, platform, session, titleID, sessionStart, duration, genre1, genre2, genre3, genre4, genre5) # did not have sessionEnd

nin <- nin |>
  select( pid, day, date, platform, session, titleID, sessionStart, duration, genre1, genre2, genre3, genre4, genre5) # removed sessionEnd

xbox <- xbox |>
  select( pid, day, date, platform, session, titleID, sessionStart, duration, genre1, genre2, genre3, genre4, genre5) # removed sessionEnd
```


```{r}
#| label: append data
telemetry <- bind_rows(nin, xbox, steam)
```

## Save data

```{r}
#| label: save-data

write_csv(telemetry, "data-synthetic/telemetry.csv")

```




# Analysis Panel Data

Panel data is analyzed using a multilevel model to account for the nested structure of the data, where repeated measurements (6 bi-weekly waves) are nested within participants. In this analysis, we examine the relationship between playtime spent on different game genres and well-being. We hypothesize that the relationship between playtime and well-being varies by genre.

within-person analysis, on with 6 bi-weekly measurement waves where wellbeing is measured for the last 2 weeks. So playtime needs to be aggregated over the 2 week time period and the proportion of total playtime spend on each genre needs to be calculated. 

## Load data
```{r}
#| label: load-data

panel_data <- read_csv("data-synthetic/synPanelClean.csv")
telemetry_data <- read_csv("data-synthetic/telemetry.csv")

```

## Recode panel data
Recode panel data to include the start and end dates for each wave.

```{r}
#| label: define the waves

# check if date is in Date format
telemetry_data$date <- as.Date(telemetry_data$date)

# Define the start and end dates for each wave in the panel data
panel_data <- panel_data |>
  mutate(
    start_date = case_when(
      wave == 1 ~ as.Date("2024-05-01"),
      wave == 2 ~ as.Date("2024-05-15"),
      wave == 3 ~ as.Date("2024-05-29"),
      wave == 4 ~ as.Date("2024-06-12"),
      wave == 5 ~ as.Date("2024-06-26"),
      wave == 6 ~ as.Date("2024-07-10")
    ),
    end_date = start_date + 13  # Each wave covers a 14-day period
  )

```

## Recode genres
There are still too many unique genre values in the genre1 column. We will group genres into broader categories to reduce the number of categories for analysis.

```{r}
#| label: check unique genres 

# Count the number of unique values in the genre1 column
unique_genres <- telemetry_data |>
  summarise(n_unique_genres = n_distinct(genre1))

# View the result
print(unique_genres)

# Display the distinct genres in the genre1 column
distinct_genres <- telemetry_data |>
  distinct(genre1)

# View the distinct genres
print(distinct_genres, n = Inf)
```

Group genres into broader categories to reduce the number of categories for analysis
```{r}
#| label: group genres

telemetry_data <- telemetry_data |>
  mutate(
    genre_grouped = case_when(
      genre1 %in% c("Action", "Adventure") ~ "Action/Adventure",
      genre1 %in% c("Hack and slash/Beat 'em up", "Fighting") ~ "Fighting",
      genre1 %in% c("Shooter") ~ "Shooter",
      genre1 %in% c("Real Time Strategy (RTS)", "Strategy", "Turn-based strategy (TBS)", "Tactical") ~ "Strategy",
      genre1 %in% c("Role-playing (RPG)") ~ "RPG",
      genre1 %in% c("MOBA") ~ "MOBA",
      genre1 %in% c("Puzzle", "Casual", "Card & Board Game") ~ "Casual/Puzzle",
      genre1 %in% c("Sport","Simulator", "Racing") ~ "Simulation/Sports/Racing",
      genre1 %in% c("Platform", "Arcade") ~ "Platform/Arcade",
      genre1 %in% c("Indie", "Music", "Visual Novel") ~ "Indie/Other",
      TRUE ~ "Other"  # This catches any genres not listed above
    )
  )

# TO DO: maybe take away categories like "indie" etc and take the second or third category
```

## Recode telemetry data
Aggregate playtime by genre within each wave for each participant.

```{r}
#| label: aggregate playtime

aggregated_playtime <- telemetry_data |>
  rowwise() |>
  mutate(wave = case_when(
    date >= as.Date("2024-05-01") & date <= as.Date("2024-05-14") ~ 1,
    date >= as.Date("2024-05-15") & date <= as.Date("2024-05-28") ~ 2,
    date >= as.Date("2024-05-29") & date <= as.Date("2024-06-11") ~ 3,
    date >= as.Date("2024-06-12") & date <= as.Date("2024-06-25") ~ 4,
    date >= as.Date("2024-06-26") & date <= as.Date("2024-07-09") ~ 5,
    date >= as.Date("2024-07-10") & date <= as.Date("2024-07-23") ~ 6
  )) |>
  group_by(pid, wave, genre_grouped) |>
  summarise(total_time = sum(duration, na.rm = TRUE)) |>
  ungroup()
```

Calculate the total playtime across all genres per wave for each participant

```{r}
#| label: calculate total playtime

total_playtime_per_wave <- aggregated_playtime |>
  group_by(pid, wave) |>
  summarise(total_time_all_genres = sum(total_time, na.rm = TRUE)) |>
  ungroup()
```

Calculate the proportion of time spent on each genre relative to the total playtime across all genres for each participant in each wave

```{r}
#| label: calculate proportion time

aggregated_playtime <- aggregated_playtime |>
  left_join(total_playtime_per_wave, by = c("pid", "wave")) |>
  mutate(proportion_time = total_time / total_time_all_genres)
```

## Merge data
Merge the aggregated playtime data with the well-being panel data

```{r}
#| label: merge data

panel_combined_data <- panel_data |>
  left_join(aggregated_playtime, by = c("pid", "wave"))
```



## H1. There is no relationship between playtime and wellbeing

This Basic Random Intercept Model allows the relationship between playtime and well-being to vary across players (random intercept) but assumes the effect of playtime is the same for all genres.

```{r}
#| label: h1_total_time

h1_total_time <- lmer(wemwbs ~ total_time + (1 | pid), data = panel_combined_data)

summary(h1_total_time)

plot_predictions( h1_total_time, condition = c("total_time"), vcov = TRUE)
```





# H2. genre moderates the relationship between playtime and wellbeing


I have multiple models to test this hypothesis. The first model examines the interaction between total time spent and each genre. The second 


## Model 1: Interaction between total time spent and each genre

```{r}
#| label: h2_interaction

h2_interaction <- lmer(wemwbs ~ total_time * genre_grouped + (1 | pid), data = panel_combined_data)

summary(h2_interaction)

plot_predictions(h2_interaction, condition = c("total_time", "genre_grouped"), vcov = TRUE)
```


## Model 2: Interaction between Total Time Spent per Genre on Each Genre

Fit the multilevel model to examine the relationship between playtime per genre and well-being

```{r}
#| label: panel model playtime

mlm_model_playtime <- lmer(wemwbs ~ total_time_all_genres * genre_grouped + (1 | pid), data = panel_combined_data)

summary(mlm_model_playtime, correlation=TRUE)

plot_predictions(mlm_model_playtime, condition = c("total_time_all_genres", "genre_grouped"), vcov = TRUE)
```

Plot interaction effect between proportion_time and genre_grouped

```{r}
#| label: plot interaction


ggplot(panel_combined_data, aes(x = total_time_all_genres, y = wemwbs, color = genre_grouped)) +
  geom_point(alpha = 0.2) +
  geom_smooth(method = "lm", se = FALSE) +
  labs(title = "Interaction Between Playtime per Genre and Genre Group",
       x = "Playtime Spent on Genre",
       y = "Well-being (WEMWBS)") +
  theme_minimal() +
  facet_wrap(~ genre_grouped)
```

## Model 3: Proportion of Time Spent on Each Genre
Model the relationship between the proportion of time spent on each genre and well-being

```{r}
#| label: panel model proportion

mlm_model_proportion <- lmer(wemwbs ~ proportion_time * genre_grouped + (1 | pid), data = panel_combined_data)

summary(mlm_model_proportion, correlation=TRUE)

plot_predictions(mlm_model_proportion, condition = c("proportion_time", "genre_grouped"), vcov = TRUE)

```

Plot interaction effect between the proportion of time spent on each genre

```{r}
#| label: plot

ggplot(panel_combined_data, aes(x = proportion_time, y = wemwbs, color = genre_grouped)) +
  geom_point(alpha = 0.2) +
  geom_smooth(method = "lm", se = FALSE) +
  labs(title = "Interaction Between Proportion of Time and Genre Group",
       x = "Proportion of Time Spent on Genre",
       y = "Well-being (WEMWBS)") +
  theme_minimal() +
  facet_wrap(~ genre_grouped)
```








# Analysis Diary data (Daily trends in daily life satisfaction)

## Load data

```{r}
#| label: Load the diary data

diary_data <- read_csv("data-synthetic/synDiaryClean.csv")
```

## Recode diary data
Create a lagged version of the daily playtime data so that we can predict life satisfaction based on the previous day's playtime.

```{r}
#| label: create lagged playtime

telemetry_data <- telemetry_data |>
  group_by(pid, genre_grouped) |>
  mutate(previous_day_duration = lag(duration, 1)) |>
  ungroup()
```

Calculate the total playtime for each genre for each day

```{r}
#| label: calculate daily playtime per genre

daily_playtime <- telemetry_data |>
  group_by(pid, day, genre_grouped) |>
  summarise(total_previous_day_duration = sum(previous_day_duration, na.rm = TRUE)) |>
  ungroup()
```

## Merge data

```{r}
#| label: merge data
diary_combined_data <- diary_data |>
  left_join(daily_playtime, by = c("pid", "day"))
```

# H1. Previous day playtime is positivly with daily life satisfaction

Predicting life satisfaction based on previous day's playtime 

```{r}
#| label: h1_model_diary

h1_model_diary <- lmer(lifeSat_1 ~ total_previous_day_duration + (1 | pid), data = diary_combined_data)

summary(h1_model_diary, correlation=TRUE)

# Plot the predictions for the effect of total_previous_day_duration
plot_predictions(h1_model_diary, condition = c("total_previous_day_duration"), vcov = TRUE)

```

# H2. Genre moderates the relationship between previous day playtime and daily life satisfaction

Predicting life satisfaction based on previous day's playtime and how it varies by genre
```{r}
#| label: h2_model_diary

h2_model_diary <- lmer(lifeSat_1 ~ total_previous_day_duration * genre_grouped + (1 | pid), data = diary_combined_data)

summary(h2_model_diary, correlation=TRUE)

# Plot the predictions for the interaction effect between total_previous_day_duration and genre1
plot_predictions(h2_model_diary, condition = c("total_previous_day_duration", "genre_grouped"), vcov = TRUE)

```

